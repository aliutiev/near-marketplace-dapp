{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getErrorTypeFromErrorMessage = exports.formatError = exports.parseResultError = exports.parseRpcError = exports.ServerError = void 0;\n\nconst mustache_1 = __importDefault(require(\"mustache\"));\n\nconst rpc_error_schema_json_1 = __importDefault(require(\"../generated/rpc_error_schema.json\"));\n\nconst error_messages_json_1 = __importDefault(require(\"../res/error_messages.json\"));\n\nconst common_index_1 = require(\"../common-index\");\n\nconst errors_1 = require(\"../utils/errors\");\n\nconst mustacheHelpers = {\n  formatNear: () => (n, render) => common_index_1.utils.format.formatNearAmount(render(n))\n};\n\nclass ServerError extends errors_1.TypedError {}\n\nexports.ServerError = ServerError;\n\nclass ServerTransactionError extends ServerError {}\n\nfunction parseRpcError(errorObj) {\n  const result = {};\n  const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, ''); // NOTE: This assumes that all errors extend TypedError\n\n  const error = new ServerError(formatError(errorClassName, result), errorClassName);\n  Object.assign(error, result);\n  return error;\n}\n\nexports.parseRpcError = parseRpcError;\n\nfunction parseResultError(result) {\n  const server_error = parseRpcError(result.status.Failure);\n  const server_tx_error = new ServerTransactionError();\n  Object.assign(server_tx_error, server_error);\n  server_tx_error.type = server_error.type;\n  server_tx_error.message = server_error.message;\n  server_tx_error.transaction_outcome = result.transaction_outcome;\n  return server_tx_error;\n}\n\nexports.parseResultError = parseResultError;\n\nfunction formatError(errorClassName, errorData) {\n  if (typeof error_messages_json_1.default[errorClassName] === 'string') {\n    return mustache_1.default.render(error_messages_json_1.default[errorClassName], { ...errorData,\n      ...mustacheHelpers\n    });\n  }\n\n  return JSON.stringify(errorData);\n}\n\nexports.formatError = formatError;\n/**\n * Walks through defined schema returning error(s) recursively\n * @param errorObj The error to be parsed\n * @param schema A defined schema in JSON mapping to the RPC errors\n * @param result An object used in recursion or called directly\n * @param typeName The human-readable error type name as defined in the JSON mapping\n */\n\nfunction walkSubtype(errorObj, schema, result, typeName) {\n  let error;\n  let type;\n  let errorTypeName;\n\n  for (const errorName in schema) {\n    if (isString(errorObj[errorName])) {\n      // Return early if error type is in a schema\n      return errorObj[errorName];\n    }\n\n    if (isObject(errorObj[errorName])) {\n      error = errorObj[errorName];\n      type = schema[errorName];\n      errorTypeName = errorName;\n    } else if (isObject(errorObj.kind) && isObject(errorObj.kind[errorName])) {\n      error = errorObj.kind[errorName];\n      type = schema[errorName];\n      errorTypeName = errorName;\n    } else {\n      continue;\n    }\n  }\n\n  if (error && type) {\n    for (const prop of Object.keys(type.props)) {\n      result[prop] = error[prop];\n    }\n\n    return walkSubtype(error, schema, result, errorTypeName);\n  } else {\n    // TODO: is this the right thing to do?\n    result.kind = errorObj;\n    return typeName;\n  }\n}\n\nfunction getErrorTypeFromErrorMessage(errorMessage) {\n  // This function should be removed when JSON RPC starts returning typed errors.\n  switch (true) {\n    case /^account .*? does not exist while viewing$/.test(errorMessage):\n      return 'AccountDoesNotExist';\n\n    case /^Account .*? doesn't exist$/.test(errorMessage):\n      return 'AccountDoesNotExist';\n\n    case /^access key .*? does not exist while viewing$/.test(errorMessage):\n      return 'AccessKeyDoesNotExist';\n\n    case /wasm execution failed with error: FunctionCallError\\(CompilationError\\(CodeDoesNotExist/.test(errorMessage):\n      return 'CodeDoesNotExist';\n\n    case /Transaction nonce \\d+ must be larger than nonce of the used access key \\d+/.test(errorMessage):\n      return 'InvalidNonce';\n\n    default:\n      return 'UntypedError';\n  }\n}\n\nexports.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage;\n/**\n * Helper function determining if the argument is an object\n * @param n Value to check\n */\n\nfunction isObject(n) {\n  return Object.prototype.toString.call(n) === '[object Object]';\n}\n/**\n * Helper function determining if the argument is a string\n * @param n Value to check\n */\n\n\nfunction isString(n) {\n  return Object.prototype.toString.call(n) === '[object String]';\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","getErrorTypeFromErrorMessage","formatError","parseResultError","parseRpcError","ServerError","mustache_1","require","rpc_error_schema_json_1","error_messages_json_1","common_index_1","errors_1","mustacheHelpers","formatNear","n","render","utils","format","formatNearAmount","TypedError","ServerTransactionError","errorObj","result","errorClassName","walkSubtype","default","schema","error","assign","server_error","status","Failure","server_tx_error","type","message","transaction_outcome","errorData","JSON","stringify","typeName","errorTypeName","errorName","isString","isObject","kind","prop","keys","props","errorMessage","test","prototype","toString","call"],"sources":["C:/Projects/node_modules/near-api-js/lib/utils/rpc_errors.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getErrorTypeFromErrorMessage = exports.formatError = exports.parseResultError = exports.parseRpcError = exports.ServerError = void 0;\nconst mustache_1 = __importDefault(require(\"mustache\"));\nconst rpc_error_schema_json_1 = __importDefault(require(\"../generated/rpc_error_schema.json\"));\nconst error_messages_json_1 = __importDefault(require(\"../res/error_messages.json\"));\nconst common_index_1 = require(\"../common-index\");\nconst errors_1 = require(\"../utils/errors\");\nconst mustacheHelpers = {\n    formatNear: () => (n, render) => common_index_1.utils.format.formatNearAmount(render(n))\n};\nclass ServerError extends errors_1.TypedError {\n}\nexports.ServerError = ServerError;\nclass ServerTransactionError extends ServerError {\n}\nfunction parseRpcError(errorObj) {\n    const result = {};\n    const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, '');\n    // NOTE: This assumes that all errors extend TypedError\n    const error = new ServerError(formatError(errorClassName, result), errorClassName);\n    Object.assign(error, result);\n    return error;\n}\nexports.parseRpcError = parseRpcError;\nfunction parseResultError(result) {\n    const server_error = parseRpcError(result.status.Failure);\n    const server_tx_error = new ServerTransactionError();\n    Object.assign(server_tx_error, server_error);\n    server_tx_error.type = server_error.type;\n    server_tx_error.message = server_error.message;\n    server_tx_error.transaction_outcome = result.transaction_outcome;\n    return server_tx_error;\n}\nexports.parseResultError = parseResultError;\nfunction formatError(errorClassName, errorData) {\n    if (typeof error_messages_json_1.default[errorClassName] === 'string') {\n        return mustache_1.default.render(error_messages_json_1.default[errorClassName], {\n            ...errorData,\n            ...mustacheHelpers\n        });\n    }\n    return JSON.stringify(errorData);\n}\nexports.formatError = formatError;\n/**\n * Walks through defined schema returning error(s) recursively\n * @param errorObj The error to be parsed\n * @param schema A defined schema in JSON mapping to the RPC errors\n * @param result An object used in recursion or called directly\n * @param typeName The human-readable error type name as defined in the JSON mapping\n */\nfunction walkSubtype(errorObj, schema, result, typeName) {\n    let error;\n    let type;\n    let errorTypeName;\n    for (const errorName in schema) {\n        if (isString(errorObj[errorName])) {\n            // Return early if error type is in a schema\n            return errorObj[errorName];\n        }\n        if (isObject(errorObj[errorName])) {\n            error = errorObj[errorName];\n            type = schema[errorName];\n            errorTypeName = errorName;\n        }\n        else if (isObject(errorObj.kind) && isObject(errorObj.kind[errorName])) {\n            error = errorObj.kind[errorName];\n            type = schema[errorName];\n            errorTypeName = errorName;\n        }\n        else {\n            continue;\n        }\n    }\n    if (error && type) {\n        for (const prop of Object.keys(type.props)) {\n            result[prop] = error[prop];\n        }\n        return walkSubtype(error, schema, result, errorTypeName);\n    }\n    else {\n        // TODO: is this the right thing to do?\n        result.kind = errorObj;\n        return typeName;\n    }\n}\nfunction getErrorTypeFromErrorMessage(errorMessage) {\n    // This function should be removed when JSON RPC starts returning typed errors.\n    switch (true) {\n        case /^account .*? does not exist while viewing$/.test(errorMessage):\n            return 'AccountDoesNotExist';\n        case /^Account .*? doesn't exist$/.test(errorMessage):\n            return 'AccountDoesNotExist';\n        case /^access key .*? does not exist while viewing$/.test(errorMessage):\n            return 'AccessKeyDoesNotExist';\n        case /wasm execution failed with error: FunctionCallError\\(CompilationError\\(CodeDoesNotExist/.test(errorMessage):\n            return 'CodeDoesNotExist';\n        case /Transaction nonce \\d+ must be larger than nonce of the used access key \\d+/.test(errorMessage):\n            return 'InvalidNonce';\n        default:\n            return 'UntypedError';\n    }\n}\nexports.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage;\n/**\n * Helper function determining if the argument is an object\n * @param n Value to check\n */\nfunction isObject(n) {\n    return Object.prototype.toString.call(n) === '[object Object]';\n}\n/**\n * Helper function determining if the argument is a string\n * @param n Value to check\n */\nfunction isString(n) {\n    return Object.prototype.toString.call(n) === '[object String]';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}