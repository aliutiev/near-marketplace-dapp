{"ast":null,"code":"'use strict';\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Account2FA = exports.AccountMultisig = exports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = exports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = void 0;\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst depd_1 = __importDefault(require(\"depd\"));\n\nconst account_1 = require(\"./account\");\n\nconst format_1 = require(\"./utils/format\");\n\nconst key_pair_1 = require(\"./utils/key_pair\");\n\nconst transaction_1 = require(\"./transaction\");\n\nconst providers_1 = require(\"./providers\");\n\nconst web_1 = require(\"./utils/web\");\n\nexports.MULTISIG_STORAGE_KEY = '__multisigRequest';\nexports.MULTISIG_ALLOWANCE = new bn_js_1.default(format_1.parseNearAmount('1')); // TODO: Different gas value for different requests (can reduce gas usage dramatically)\n\nexports.MULTISIG_GAS = new bn_js_1.default('100000000000000');\nexports.MULTISIG_DEPOSIT = new bn_js_1.default('0');\nexports.MULTISIG_CHANGE_METHODS = ['add_request', 'add_request_and_confirm', 'delete_request', 'confirm'];\nexports.MULTISIG_CONFIRM_METHODS = ['confirm'];\nvar MultisigDeleteRequestRejectionError;\n\n(function (MultisigDeleteRequestRejectionError) {\n  MultisigDeleteRequestRejectionError[\"CANNOT_DESERIALIZE_STATE\"] = \"Cannot deserialize the contract state\";\n  MultisigDeleteRequestRejectionError[\"MULTISIG_NOT_INITIALIZED\"] = \"Smart contract panicked: Multisig contract should be initialized before usage\";\n  MultisigDeleteRequestRejectionError[\"NO_SUCH_REQUEST\"] = \"Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'\";\n  MultisigDeleteRequestRejectionError[\"REQUEST_COOLDOWN_ERROR\"] = \"Request cannot be deleted immediately after creation.\";\n  MultisigDeleteRequestRejectionError[\"METHOD_NOT_FOUND\"] = \"Contract method is not found\";\n})(MultisigDeleteRequestRejectionError = exports.MultisigDeleteRequestRejectionError || (exports.MultisigDeleteRequestRejectionError = {}));\n\n;\nvar MultisigStateStatus;\n\n(function (MultisigStateStatus) {\n  MultisigStateStatus[MultisigStateStatus[\"INVALID_STATE\"] = 0] = \"INVALID_STATE\";\n  MultisigStateStatus[MultisigStateStatus[\"STATE_NOT_INITIALIZED\"] = 1] = \"STATE_NOT_INITIALIZED\";\n  MultisigStateStatus[MultisigStateStatus[\"VALID_STATE\"] = 2] = \"VALID_STATE\";\n  MultisigStateStatus[MultisigStateStatus[\"UNKNOWN_STATE\"] = 3] = \"UNKNOWN_STATE\";\n})(MultisigStateStatus = exports.MultisigStateStatus || (exports.MultisigStateStatus = {}));\n\nvar MultisigCodeStatus;\n\n(function (MultisigCodeStatus) {\n  MultisigCodeStatus[MultisigCodeStatus[\"INVALID_CODE\"] = 0] = \"INVALID_CODE\";\n  MultisigCodeStatus[MultisigCodeStatus[\"VALID_CODE\"] = 1] = \"VALID_CODE\";\n  MultisigCodeStatus[MultisigCodeStatus[\"UNKNOWN_CODE\"] = 2] = \"UNKNOWN_CODE\";\n})(MultisigCodeStatus || (MultisigCodeStatus = {})); // in memory request cache for node w/o localStorage\n\n\nconst storageFallback = {\n  [exports.MULTISIG_STORAGE_KEY]: null\n};\n\nclass AccountMultisig extends account_1.Account {\n  constructor(connection, accountId, options) {\n    super(connection, accountId);\n    this.storage = options.storage;\n    this.onAddRequestResult = options.onAddRequestResult;\n  }\n\n  async signAndSendTransactionWithAccount(receiverId, actions) {\n    return super.signAndSendTransaction({\n      receiverId,\n      actions\n    });\n  }\n\n  signAndSendTransaction() {\n    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {\n      return this._signAndSendTransaction({\n        receiverId: arguments.length <= 0 ? undefined : arguments[0],\n        actions: arguments.length <= 1 ? undefined : arguments[1]\n      });\n    }\n\n    return this._signAndSendTransaction(arguments.length <= 0 ? undefined : arguments[0]);\n  }\n\n  async _signAndSendTransaction(_ref) {\n    let {\n      receiverId,\n      actions\n    } = _ref;\n    const {\n      accountId\n    } = this;\n    const args = Buffer.from(JSON.stringify({\n      request: {\n        receiver_id: receiverId,\n        actions: convertActions(actions, accountId, receiverId)\n      }\n    }));\n    let result;\n\n    try {\n      result = await super.signAndSendTransaction({\n        receiverId: accountId,\n        actions: [transaction_1.functionCall('add_request_and_confirm', args, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]\n      });\n    } catch (e) {\n      if (e.toString().includes('Account has too many active requests. Confirm or delete some')) {\n        await this.deleteUnconfirmedRequests();\n        return await this.signAndSendTransaction(receiverId, actions);\n      }\n\n      throw e;\n    } // TODO: Are following even needed? Seems like it throws on error already\n\n\n    if (!result.status) {\n      throw new Error('Request failed');\n    }\n\n    const status = { ...result.status\n    };\n\n    if (!status.SuccessValue || typeof status.SuccessValue !== 'string') {\n      throw new Error('Request failed');\n    }\n\n    this.setRequest({\n      accountId,\n      actions,\n      requestId: parseInt(Buffer.from(status.SuccessValue, 'base64').toString('ascii'), 10)\n    });\n\n    if (this.onAddRequestResult) {\n      await this.onAddRequestResult(result);\n    } // NOTE there is no await on purpose to avoid blocking for 2fa\n\n\n    this.deleteUnconfirmedRequests();\n    return result;\n  }\n  /*\n   * This method submits a canary transaction that is expected to always fail in order to determine whether the contract currently has valid multisig state\n   * and whether it is initialized. The canary transaction attempts to delete a request at index u32_max and will go through if a request exists at that index.\n   * a u32_max + 1 and -1 value cannot be used for the canary due to expected u32 error thrown before deserialization attempt.\n   */\n\n\n  async checkMultisigCodeAndStateStatus(contractBytes) {\n    const u32_max = 4294967295;\n    const validCodeStatusIfNoDeploy = contractBytes ? MultisigCodeStatus.UNKNOWN_CODE : MultisigCodeStatus.VALID_CODE;\n\n    try {\n      if (contractBytes) {\n        await super.signAndSendTransaction({\n          receiverId: this.accountId,\n          actions: [transaction_1.deployContract(contractBytes), transaction_1.functionCall('delete_request', {\n            request_id: u32_max\n          }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]\n        });\n      } else {\n        await this.deleteRequest(u32_max);\n      }\n\n      return {\n        codeStatus: MultisigCodeStatus.VALID_CODE,\n        stateStatus: MultisigStateStatus.VALID_STATE\n      };\n    } catch (e) {\n      if (new RegExp(MultisigDeleteRequestRejectionError.CANNOT_DESERIALIZE_STATE).test(e && e.kind && e.kind.ExecutionError)) {\n        return {\n          codeStatus: validCodeStatusIfNoDeploy,\n          stateStatus: MultisigStateStatus.INVALID_STATE\n        };\n      } else if (new RegExp(MultisigDeleteRequestRejectionError.MULTISIG_NOT_INITIALIZED).test(e && e.kind && e.kind.ExecutionError)) {\n        return {\n          codeStatus: validCodeStatusIfNoDeploy,\n          stateStatus: MultisigStateStatus.STATE_NOT_INITIALIZED\n        };\n      } else if (new RegExp(MultisigDeleteRequestRejectionError.NO_SUCH_REQUEST).test(e && e.kind && e.kind.ExecutionError)) {\n        return {\n          codeStatus: validCodeStatusIfNoDeploy,\n          stateStatus: MultisigStateStatus.VALID_STATE\n        };\n      } else if (new RegExp(MultisigDeleteRequestRejectionError.METHOD_NOT_FOUND).test(e && e.message)) {\n        // not reachable if transaction included a deploy\n        return {\n          codeStatus: MultisigCodeStatus.INVALID_CODE,\n          stateStatus: MultisigStateStatus.UNKNOWN_STATE\n        };\n      }\n\n      throw e;\n    }\n  }\n\n  deleteRequest(request_id) {\n    return super.signAndSendTransaction({\n      receiverId: this.accountId,\n      actions: [transaction_1.functionCall('delete_request', {\n        request_id\n      }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]\n    });\n  }\n\n  async deleteAllRequests() {\n    const request_ids = await this.getRequestIds();\n\n    if (request_ids.length) {\n      await Promise.all(request_ids.map(id => this.deleteRequest(id)));\n    }\n  }\n\n  async deleteUnconfirmedRequests() {\n    // TODO: Delete in batch, don't delete unexpired\n    // TODO: Delete in batch, don't delete unexpired (can reduce gas usage dramatically)\n    const request_ids = await this.getRequestIds();\n    const {\n      requestId\n    } = this.getRequest();\n\n    for (const requestIdToDelete of request_ids) {\n      if (requestIdToDelete == requestId) {\n        continue;\n      }\n\n      try {\n        await super.signAndSendTransaction({\n          receiverId: this.accountId,\n          actions: [transaction_1.functionCall('delete_request', {\n            request_id: requestIdToDelete\n          }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]\n        });\n      } catch (e) {\n        console.warn('Attempt to delete an earlier request before 15 minutes failed. Will try again.');\n      }\n    }\n  } // helpers\n\n\n  async getRequestIds() {\n    // TODO: Read requests from state to allow filtering by expiration time\n    // TODO: https://github.com/near/core-contracts/blob/305d1db4f4f2cf5ce4c1ef3479f7544957381f11/multisig/src/lib.rs#L84\n    return this.viewFunction(this.accountId, 'list_request_ids');\n  }\n\n  getRequest() {\n    if (this.storage) {\n      return JSON.parse(this.storage.getItem(exports.MULTISIG_STORAGE_KEY) || '{}');\n    }\n\n    return storageFallback[exports.MULTISIG_STORAGE_KEY];\n  }\n\n  setRequest(data) {\n    if (this.storage) {\n      return this.storage.setItem(exports.MULTISIG_STORAGE_KEY, JSON.stringify(data));\n    }\n\n    storageFallback[exports.MULTISIG_STORAGE_KEY] = data;\n  }\n\n}\n\nexports.AccountMultisig = AccountMultisig;\n\nclass Account2FA extends AccountMultisig {\n  constructor(connection, accountId, options) {\n    super(connection, accountId, options);\n    this.helperUrl = 'https://helper.testnet.near.org';\n    this.helperUrl = options.helperUrl || this.helperUrl;\n    this.storage = options.storage;\n    this.sendCode = options.sendCode || this.sendCodeDefault;\n    this.getCode = options.getCode || this.getCodeDefault;\n    this.verifyCode = options.verifyCode || this.verifyCodeDefault;\n    this.onConfirmResult = options.onConfirmResult;\n  }\n\n  async signAndSendTransaction() {\n    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {\n      const deprecate = depd_1.default('Account.signAndSendTransaction(receiverId, actions');\n      deprecate('use `Account2FA.signAndSendTransaction(SignAndSendTransactionOptions)` instead');\n      return this.__signAndSendTransaction({\n        receiverId: arguments.length <= 0 ? undefined : arguments[0],\n        actions: arguments.length <= 1 ? undefined : arguments[1]\n      });\n    } else {\n      return this.__signAndSendTransaction(arguments.length <= 0 ? undefined : arguments[0]);\n    }\n  }\n\n  async __signAndSendTransaction(_ref2) {\n    let {\n      receiverId,\n      actions\n    } = _ref2;\n    await super.signAndSendTransaction({\n      receiverId,\n      actions\n    }); // TODO: Should following override onRequestResult in superclass instead of doing custom signAndSendTransaction?\n\n    await this.sendCode();\n    const result = await this.promptAndVerify();\n\n    if (this.onConfirmResult) {\n      await this.onConfirmResult(result);\n    }\n\n    return result;\n  } // default helpers for CH deployments of multisig\n\n\n  async deployMultisig(contractBytes) {\n    const {\n      accountId\n    } = this;\n    const seedOrLedgerKey = (await this.getRecoveryMethods()).data.filter(_ref3 => {\n      let {\n        kind,\n        publicKey\n      } = _ref3;\n      return (kind === 'phrase' || kind === 'ledger') && publicKey !== null;\n    }).map(rm => rm.publicKey);\n    const fak2lak = (await this.getAccessKeys()).filter(_ref4 => {\n      let {\n        public_key,\n        access_key: {\n          permission\n        }\n      } = _ref4;\n      return permission === 'FullAccess' && !seedOrLedgerKey.includes(public_key);\n    }).map(ak => ak.public_key).map(toPK);\n    const confirmOnlyKey = toPK((await this.postSignedJson('/2fa/getAccessKey', {\n      accountId\n    })).publicKey);\n    const newArgs = Buffer.from(JSON.stringify({\n      'num_confirmations': 2\n    }));\n    const actions = [...fak2lak.map(pk => transaction_1.deleteKey(pk)), ...fak2lak.map(pk => transaction_1.addKey(pk, transaction_1.functionCallAccessKey(accountId, exports.MULTISIG_CHANGE_METHODS, null))), transaction_1.addKey(confirmOnlyKey, transaction_1.functionCallAccessKey(accountId, exports.MULTISIG_CONFIRM_METHODS, null)), transaction_1.deployContract(contractBytes)];\n    const newFunctionCallActionBatch = actions.concat(transaction_1.functionCall('new', newArgs, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT));\n    console.log('deploying multisig contract for', accountId);\n    const {\n      stateStatus: multisigStateStatus\n    } = await this.checkMultisigCodeAndStateStatus(contractBytes);\n\n    switch (multisigStateStatus) {\n      case MultisigStateStatus.STATE_NOT_INITIALIZED:\n        return await super.signAndSendTransactionWithAccount(accountId, newFunctionCallActionBatch);\n\n      case MultisigStateStatus.VALID_STATE:\n        return await super.signAndSendTransactionWithAccount(accountId, actions);\n\n      case MultisigStateStatus.INVALID_STATE:\n        throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState');\n\n      default:\n        throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n    }\n  }\n\n  async disableWithFAK(_ref5) {\n    let {\n      contractBytes,\n      cleanupContractBytes\n    } = _ref5;\n    let cleanupActions = [];\n\n    if (cleanupContractBytes) {\n      await this.deleteAllRequests().catch(e => e);\n      cleanupActions = await this.get2faDisableCleanupActions(cleanupContractBytes);\n    }\n\n    const keyConversionActions = await this.get2faDisableKeyConversionActions();\n    const actions = [...cleanupActions, ...keyConversionActions, transaction_1.deployContract(contractBytes)];\n    const accessKeyInfo = await this.findAccessKey(this.accountId, actions);\n\n    if (accessKeyInfo && accessKeyInfo.accessKey && accessKeyInfo.accessKey.permission !== 'FullAccess') {\n      throw new providers_1.TypedError(`No full access key found in keystore. Unable to bypass multisig`, 'NoFAKFound');\n    }\n\n    return this.signAndSendTransactionWithAccount(this.accountId, actions);\n  }\n\n  async get2faDisableCleanupActions(cleanupContractBytes) {\n    const currentAccountState = await this.viewState('').catch(error => {\n      const cause = error.cause && error.cause.name;\n\n      if (cause == 'NO_CONTRACT_CODE') {\n        return [];\n      }\n\n      throw cause == 'TOO_LARGE_CONTRACT_STATE' ? new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState') : error;\n    });\n    const currentAccountStateKeys = currentAccountState.map(_ref6 => {\n      let {\n        key\n      } = _ref6;\n      return key.toString('base64');\n    });\n    return currentAccountState.length ? [transaction_1.deployContract(cleanupContractBytes), transaction_1.functionCall('clean', {\n      keys: currentAccountStateKeys\n    }, exports.MULTISIG_GAS, new bn_js_1.default('0'))] : [];\n  }\n\n  async get2faDisableKeyConversionActions() {\n    const {\n      accountId\n    } = this;\n    const accessKeys = await this.getAccessKeys();\n    const lak2fak = accessKeys.filter(_ref7 => {\n      let {\n        access_key\n      } = _ref7;\n      return access_key.permission !== 'FullAccess';\n    }).filter(_ref8 => {\n      let {\n        access_key\n      } = _ref8;\n      const perm = access_key.permission.FunctionCall;\n      return perm.receiver_id === accountId && perm.method_names.length === 4 && perm.method_names.includes('add_request_and_confirm');\n    });\n    const confirmOnlyKey = key_pair_1.PublicKey.from((await this.postSignedJson('/2fa/getAccessKey', {\n      accountId\n    })).publicKey);\n    return [transaction_1.deleteKey(confirmOnlyKey), ...lak2fak.map(_ref9 => {\n      let {\n        public_key\n      } = _ref9;\n      return transaction_1.deleteKey(key_pair_1.PublicKey.from(public_key));\n    }), ...lak2fak.map(_ref10 => {\n      let {\n        public_key\n      } = _ref10;\n      return transaction_1.addKey(key_pair_1.PublicKey.from(public_key), transaction_1.fullAccessKey());\n    })];\n  }\n  /**\n   * This method converts LAKs back to FAKs, clears state and deploys an 'empty' contract (contractBytes param)\n   * @param [contractBytes]{@link https://github.com/near/near-wallet/blob/master/packages/frontend/src/wasm/main.wasm?raw=true}\n   * @param [cleanupContractBytes]{@link https://github.com/near/core-contracts/blob/master/state-cleanup/res/state_cleanup.wasm?raw=true}\n   */\n\n\n  async disable(contractBytes, cleanupContractBytes) {\n    const {\n      stateStatus\n    } = await this.checkMultisigCodeAndStateStatus();\n\n    if (stateStatus !== MultisigStateStatus.VALID_STATE && stateStatus !== MultisigStateStatus.STATE_NOT_INITIALIZED) {\n      throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n    }\n\n    let deleteAllRequestsError;\n    await this.deleteAllRequests().catch(e => deleteAllRequestsError = e);\n    const cleanupActions = await this.get2faDisableCleanupActions(cleanupContractBytes).catch(e => {\n      if (e.type === 'ContractHasExistingState') {\n        throw deleteAllRequestsError || e;\n      }\n\n      throw e;\n    });\n    const actions = [...cleanupActions, ...(await this.get2faDisableKeyConversionActions()), transaction_1.deployContract(contractBytes)];\n    console.log('disabling 2fa for', this.accountId);\n    return await this.signAndSendTransaction({\n      receiverId: this.accountId,\n      actions\n    });\n  }\n\n  async sendCodeDefault() {\n    const {\n      accountId\n    } = this;\n    const {\n      requestId\n    } = this.getRequest();\n    const method = await this.get2faMethod();\n    await this.postSignedJson('/2fa/send', {\n      accountId,\n      method,\n      requestId\n    });\n    return requestId;\n  }\n\n  async getCodeDefault(method) {\n    throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is \"email\" or \"phone\".');\n  }\n\n  async promptAndVerify() {\n    const method = await this.get2faMethod();\n    const securityCode = await this.getCode(method);\n\n    try {\n      const result = await this.verifyCode(securityCode); // TODO: Parse error from result for real (like in normal account.signAndSendTransaction)\n\n      return result;\n    } catch (e) {\n      console.warn('Error validating security code:', e);\n\n      if (e.toString().includes('invalid 2fa code provided') || e.toString().includes('2fa code not valid')) {\n        return await this.promptAndVerify();\n      }\n\n      throw e;\n    }\n  }\n\n  async verifyCodeDefault(securityCode) {\n    const {\n      accountId\n    } = this;\n    const request = this.getRequest();\n\n    if (!request) {\n      throw new Error('no request pending');\n    }\n\n    const {\n      requestId\n    } = request;\n    return await this.postSignedJson('/2fa/verify', {\n      accountId,\n      securityCode,\n      requestId\n    });\n  }\n\n  async getRecoveryMethods() {\n    const {\n      accountId\n    } = this;\n    return {\n      accountId,\n      data: await this.postSignedJson('/account/recoveryMethods', {\n        accountId\n      })\n    };\n  }\n\n  async get2faMethod() {\n    let {\n      data\n    } = await this.getRecoveryMethods();\n\n    if (data && data.length) {\n      data = data.find(m => m.kind.indexOf('2fa-') === 0);\n    }\n\n    if (!data) return null;\n    const {\n      kind,\n      detail\n    } = data;\n    return {\n      kind,\n      detail\n    };\n  }\n\n  async signatureFor() {\n    const {\n      accountId\n    } = this;\n    const block = await this.connection.provider.block({\n      finality: 'final'\n    });\n    const blockNumber = block.header.height.toString();\n    const signed = await this.connection.signer.signMessage(Buffer.from(blockNumber), accountId, this.connection.networkId);\n    const blockNumberSignature = Buffer.from(signed.signature).toString('base64');\n    return {\n      blockNumber,\n      blockNumberSignature\n    };\n  }\n\n  async postSignedJson(path, body) {\n    return await web_1.fetchJson(this.helperUrl + path, JSON.stringify({ ...body,\n      ...(await this.signatureFor())\n    }));\n  }\n\n}\n\nexports.Account2FA = Account2FA; // helpers\n\nconst toPK = pk => key_pair_1.PublicKey.from(pk);\n\nconst convertPKForContract = pk => pk.toString().replace('ed25519:', '');\n\nconst convertActions = (actions, accountId, receiverId) => actions.map(a => {\n  const type = a.enum;\n  const {\n    gas,\n    publicKey,\n    methodName,\n    args,\n    deposit,\n    accessKey,\n    code\n  } = a[type];\n  const action = {\n    type: type[0].toUpperCase() + type.substr(1),\n    gas: gas && gas.toString() || undefined,\n    public_key: publicKey && convertPKForContract(publicKey) || undefined,\n    method_name: methodName,\n    args: args && Buffer.from(args).toString('base64') || undefined,\n    code: code && Buffer.from(code).toString('base64') || undefined,\n    amount: deposit && deposit.toString() || undefined,\n    deposit: deposit && deposit.toString() || '0',\n    permission: undefined\n  };\n\n  if (accessKey) {\n    if (receiverId === accountId && accessKey.permission.enum !== 'fullAccess') {\n      action.permission = {\n        receiver_id: accountId,\n        allowance: exports.MULTISIG_ALLOWANCE.toString(),\n        method_names: exports.MULTISIG_CHANGE_METHODS\n      };\n    }\n\n    if (accessKey.permission.enum === 'functionCall') {\n      const {\n        receiverId: receiver_id,\n        methodNames: method_names,\n        allowance\n      } = accessKey.permission.functionCall;\n      action.permission = {\n        receiver_id,\n        allowance: allowance && allowance.toString() || undefined,\n        method_names\n      };\n    }\n  }\n\n  return action;\n});","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Account2FA","AccountMultisig","MultisigStateStatus","MultisigDeleteRequestRejectionError","MULTISIG_CONFIRM_METHODS","MULTISIG_CHANGE_METHODS","MULTISIG_DEPOSIT","MULTISIG_GAS","MULTISIG_ALLOWANCE","MULTISIG_STORAGE_KEY","bn_js_1","require","depd_1","account_1","format_1","key_pair_1","transaction_1","providers_1","web_1","default","parseNearAmount","MultisigCodeStatus","storageFallback","Account","constructor","connection","accountId","options","storage","onAddRequestResult","signAndSendTransactionWithAccount","receiverId","actions","signAndSendTransaction","_signAndSendTransaction","args","Buffer","from","JSON","stringify","request","receiver_id","convertActions","result","functionCall","e","toString","includes","deleteUnconfirmedRequests","status","Error","SuccessValue","setRequest","requestId","parseInt","checkMultisigCodeAndStateStatus","contractBytes","u32_max","validCodeStatusIfNoDeploy","UNKNOWN_CODE","VALID_CODE","deployContract","request_id","deleteRequest","codeStatus","stateStatus","VALID_STATE","RegExp","CANNOT_DESERIALIZE_STATE","test","kind","ExecutionError","INVALID_STATE","MULTISIG_NOT_INITIALIZED","STATE_NOT_INITIALIZED","NO_SUCH_REQUEST","METHOD_NOT_FOUND","message","INVALID_CODE","UNKNOWN_STATE","deleteAllRequests","request_ids","getRequestIds","length","Promise","all","map","id","getRequest","requestIdToDelete","console","warn","viewFunction","parse","getItem","data","setItem","helperUrl","sendCode","sendCodeDefault","getCode","getCodeDefault","verifyCode","verifyCodeDefault","onConfirmResult","deprecate","__signAndSendTransaction","promptAndVerify","deployMultisig","seedOrLedgerKey","getRecoveryMethods","filter","publicKey","rm","fak2lak","getAccessKeys","public_key","access_key","permission","ak","toPK","confirmOnlyKey","postSignedJson","newArgs","pk","deleteKey","addKey","functionCallAccessKey","newFunctionCallActionBatch","concat","log","multisigStateStatus","TypedError","networkId","disableWithFAK","cleanupContractBytes","cleanupActions","catch","get2faDisableCleanupActions","keyConversionActions","get2faDisableKeyConversionActions","accessKeyInfo","findAccessKey","accessKey","currentAccountState","viewState","error","cause","name","currentAccountStateKeys","key","keys","accessKeys","lak2fak","perm","FunctionCall","method_names","PublicKey","fullAccessKey","disable","deleteAllRequestsError","type","method","get2faMethod","securityCode","find","m","indexOf","detail","signatureFor","block","provider","finality","blockNumber","header","height","signed","signer","signMessage","blockNumberSignature","signature","path","body","fetchJson","convertPKForContract","replace","a","enum","gas","methodName","deposit","code","action","toUpperCase","substr","undefined","method_name","amount","allowance","methodNames"],"sources":["C:/Projects/node_modules/near-api-js/lib/account_multisig.js"],"sourcesContent":["'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Account2FA = exports.AccountMultisig = exports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = exports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst depd_1 = __importDefault(require(\"depd\"));\nconst account_1 = require(\"./account\");\nconst format_1 = require(\"./utils/format\");\nconst key_pair_1 = require(\"./utils/key_pair\");\nconst transaction_1 = require(\"./transaction\");\nconst providers_1 = require(\"./providers\");\nconst web_1 = require(\"./utils/web\");\nexports.MULTISIG_STORAGE_KEY = '__multisigRequest';\nexports.MULTISIG_ALLOWANCE = new bn_js_1.default(format_1.parseNearAmount('1'));\n// TODO: Different gas value for different requests (can reduce gas usage dramatically)\nexports.MULTISIG_GAS = new bn_js_1.default('100000000000000');\nexports.MULTISIG_DEPOSIT = new bn_js_1.default('0');\nexports.MULTISIG_CHANGE_METHODS = ['add_request', 'add_request_and_confirm', 'delete_request', 'confirm'];\nexports.MULTISIG_CONFIRM_METHODS = ['confirm'];\nvar MultisigDeleteRequestRejectionError;\n(function (MultisigDeleteRequestRejectionError) {\n    MultisigDeleteRequestRejectionError[\"CANNOT_DESERIALIZE_STATE\"] = \"Cannot deserialize the contract state\";\n    MultisigDeleteRequestRejectionError[\"MULTISIG_NOT_INITIALIZED\"] = \"Smart contract panicked: Multisig contract should be initialized before usage\";\n    MultisigDeleteRequestRejectionError[\"NO_SUCH_REQUEST\"] = \"Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'\";\n    MultisigDeleteRequestRejectionError[\"REQUEST_COOLDOWN_ERROR\"] = \"Request cannot be deleted immediately after creation.\";\n    MultisigDeleteRequestRejectionError[\"METHOD_NOT_FOUND\"] = \"Contract method is not found\";\n})(MultisigDeleteRequestRejectionError = exports.MultisigDeleteRequestRejectionError || (exports.MultisigDeleteRequestRejectionError = {}));\n;\nvar MultisigStateStatus;\n(function (MultisigStateStatus) {\n    MultisigStateStatus[MultisigStateStatus[\"INVALID_STATE\"] = 0] = \"INVALID_STATE\";\n    MultisigStateStatus[MultisigStateStatus[\"STATE_NOT_INITIALIZED\"] = 1] = \"STATE_NOT_INITIALIZED\";\n    MultisigStateStatus[MultisigStateStatus[\"VALID_STATE\"] = 2] = \"VALID_STATE\";\n    MultisigStateStatus[MultisigStateStatus[\"UNKNOWN_STATE\"] = 3] = \"UNKNOWN_STATE\";\n})(MultisigStateStatus = exports.MultisigStateStatus || (exports.MultisigStateStatus = {}));\nvar MultisigCodeStatus;\n(function (MultisigCodeStatus) {\n    MultisigCodeStatus[MultisigCodeStatus[\"INVALID_CODE\"] = 0] = \"INVALID_CODE\";\n    MultisigCodeStatus[MultisigCodeStatus[\"VALID_CODE\"] = 1] = \"VALID_CODE\";\n    MultisigCodeStatus[MultisigCodeStatus[\"UNKNOWN_CODE\"] = 2] = \"UNKNOWN_CODE\";\n})(MultisigCodeStatus || (MultisigCodeStatus = {}));\n// in memory request cache for node w/o localStorage\nconst storageFallback = {\n    [exports.MULTISIG_STORAGE_KEY]: null\n};\nclass AccountMultisig extends account_1.Account {\n    constructor(connection, accountId, options) {\n        super(connection, accountId);\n        this.storage = options.storage;\n        this.onAddRequestResult = options.onAddRequestResult;\n    }\n    async signAndSendTransactionWithAccount(receiverId, actions) {\n        return super.signAndSendTransaction({ receiverId, actions });\n    }\n    signAndSendTransaction(...args) {\n        if (typeof args[0] === 'string') {\n            return this._signAndSendTransaction({ receiverId: args[0], actions: args[1] });\n        }\n        return this._signAndSendTransaction(args[0]);\n    }\n    async _signAndSendTransaction({ receiverId, actions }) {\n        const { accountId } = this;\n        const args = Buffer.from(JSON.stringify({\n            request: {\n                receiver_id: receiverId,\n                actions: convertActions(actions, accountId, receiverId)\n            }\n        }));\n        let result;\n        try {\n            result = await super.signAndSendTransaction({\n                receiverId: accountId,\n                actions: [\n                    transaction_1.functionCall('add_request_and_confirm', args, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)\n                ]\n            });\n        }\n        catch (e) {\n            if (e.toString().includes('Account has too many active requests. Confirm or delete some')) {\n                await this.deleteUnconfirmedRequests();\n                return await this.signAndSendTransaction(receiverId, actions);\n            }\n            throw e;\n        }\n        // TODO: Are following even needed? Seems like it throws on error already\n        if (!result.status) {\n            throw new Error('Request failed');\n        }\n        const status = { ...result.status };\n        if (!status.SuccessValue || typeof status.SuccessValue !== 'string') {\n            throw new Error('Request failed');\n        }\n        this.setRequest({\n            accountId,\n            actions,\n            requestId: parseInt(Buffer.from(status.SuccessValue, 'base64').toString('ascii'), 10)\n        });\n        if (this.onAddRequestResult) {\n            await this.onAddRequestResult(result);\n        }\n        // NOTE there is no await on purpose to avoid blocking for 2fa\n        this.deleteUnconfirmedRequests();\n        return result;\n    }\n    /*\n     * This method submits a canary transaction that is expected to always fail in order to determine whether the contract currently has valid multisig state\n     * and whether it is initialized. The canary transaction attempts to delete a request at index u32_max and will go through if a request exists at that index.\n     * a u32_max + 1 and -1 value cannot be used for the canary due to expected u32 error thrown before deserialization attempt.\n     */\n    async checkMultisigCodeAndStateStatus(contractBytes) {\n        const u32_max = 4294967295;\n        const validCodeStatusIfNoDeploy = contractBytes ? MultisigCodeStatus.UNKNOWN_CODE : MultisigCodeStatus.VALID_CODE;\n        try {\n            if (contractBytes) {\n                await super.signAndSendTransaction({\n                    receiverId: this.accountId, actions: [\n                        transaction_1.deployContract(contractBytes),\n                        transaction_1.functionCall('delete_request', { request_id: u32_max }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)\n                    ]\n                });\n            }\n            else {\n                await this.deleteRequest(u32_max);\n            }\n            return { codeStatus: MultisigCodeStatus.VALID_CODE, stateStatus: MultisigStateStatus.VALID_STATE };\n        }\n        catch (e) {\n            if (new RegExp(MultisigDeleteRequestRejectionError.CANNOT_DESERIALIZE_STATE).test(e && e.kind && e.kind.ExecutionError)) {\n                return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: MultisigStateStatus.INVALID_STATE };\n            }\n            else if (new RegExp(MultisigDeleteRequestRejectionError.MULTISIG_NOT_INITIALIZED).test(e && e.kind && e.kind.ExecutionError)) {\n                return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: MultisigStateStatus.STATE_NOT_INITIALIZED };\n            }\n            else if (new RegExp(MultisigDeleteRequestRejectionError.NO_SUCH_REQUEST).test(e && e.kind && e.kind.ExecutionError)) {\n                return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: MultisigStateStatus.VALID_STATE };\n            }\n            else if (new RegExp(MultisigDeleteRequestRejectionError.METHOD_NOT_FOUND).test(e && e.message)) {\n                // not reachable if transaction included a deploy\n                return { codeStatus: MultisigCodeStatus.INVALID_CODE, stateStatus: MultisigStateStatus.UNKNOWN_STATE };\n            }\n            throw e;\n        }\n    }\n    deleteRequest(request_id) {\n        return super.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [transaction_1.functionCall('delete_request', { request_id }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]\n        });\n    }\n    async deleteAllRequests() {\n        const request_ids = await this.getRequestIds();\n        if (request_ids.length) {\n            await Promise.all(request_ids.map((id) => this.deleteRequest(id)));\n        }\n    }\n    async deleteUnconfirmedRequests() {\n        // TODO: Delete in batch, don't delete unexpired\n        // TODO: Delete in batch, don't delete unexpired (can reduce gas usage dramatically)\n        const request_ids = await this.getRequestIds();\n        const { requestId } = this.getRequest();\n        for (const requestIdToDelete of request_ids) {\n            if (requestIdToDelete == requestId) {\n                continue;\n            }\n            try {\n                await super.signAndSendTransaction({\n                    receiverId: this.accountId,\n                    actions: [transaction_1.functionCall('delete_request', { request_id: requestIdToDelete }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]\n                });\n            }\n            catch (e) {\n                console.warn('Attempt to delete an earlier request before 15 minutes failed. Will try again.');\n            }\n        }\n    }\n    // helpers\n    async getRequestIds() {\n        // TODO: Read requests from state to allow filtering by expiration time\n        // TODO: https://github.com/near/core-contracts/blob/305d1db4f4f2cf5ce4c1ef3479f7544957381f11/multisig/src/lib.rs#L84\n        return this.viewFunction(this.accountId, 'list_request_ids');\n    }\n    getRequest() {\n        if (this.storage) {\n            return JSON.parse(this.storage.getItem(exports.MULTISIG_STORAGE_KEY) || '{}');\n        }\n        return storageFallback[exports.MULTISIG_STORAGE_KEY];\n    }\n    setRequest(data) {\n        if (this.storage) {\n            return this.storage.setItem(exports.MULTISIG_STORAGE_KEY, JSON.stringify(data));\n        }\n        storageFallback[exports.MULTISIG_STORAGE_KEY] = data;\n    }\n}\nexports.AccountMultisig = AccountMultisig;\nclass Account2FA extends AccountMultisig {\n    constructor(connection, accountId, options) {\n        super(connection, accountId, options);\n        this.helperUrl = 'https://helper.testnet.near.org';\n        this.helperUrl = options.helperUrl || this.helperUrl;\n        this.storage = options.storage;\n        this.sendCode = options.sendCode || this.sendCodeDefault;\n        this.getCode = options.getCode || this.getCodeDefault;\n        this.verifyCode = options.verifyCode || this.verifyCodeDefault;\n        this.onConfirmResult = options.onConfirmResult;\n    }\n    async signAndSendTransaction(...args) {\n        if (typeof args[0] === 'string') {\n            const deprecate = depd_1.default('Account.signAndSendTransaction(receiverId, actions');\n            deprecate('use `Account2FA.signAndSendTransaction(SignAndSendTransactionOptions)` instead');\n            return this.__signAndSendTransaction({ receiverId: args[0], actions: args[1] });\n        }\n        else {\n            return this.__signAndSendTransaction(args[0]);\n        }\n    }\n    async __signAndSendTransaction({ receiverId, actions }) {\n        await super.signAndSendTransaction({ receiverId, actions });\n        // TODO: Should following override onRequestResult in superclass instead of doing custom signAndSendTransaction?\n        await this.sendCode();\n        const result = await this.promptAndVerify();\n        if (this.onConfirmResult) {\n            await this.onConfirmResult(result);\n        }\n        return result;\n    }\n    // default helpers for CH deployments of multisig\n    async deployMultisig(contractBytes) {\n        const { accountId } = this;\n        const seedOrLedgerKey = (await this.getRecoveryMethods()).data\n            .filter(({ kind, publicKey }) => (kind === 'phrase' || kind === 'ledger') && publicKey !== null)\n            .map((rm) => rm.publicKey);\n        const fak2lak = (await this.getAccessKeys())\n            .filter(({ public_key, access_key: { permission } }) => permission === 'FullAccess' && !seedOrLedgerKey.includes(public_key))\n            .map((ak) => ak.public_key)\n            .map(toPK);\n        const confirmOnlyKey = toPK((await this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);\n        const newArgs = Buffer.from(JSON.stringify({ 'num_confirmations': 2 }));\n        const actions = [\n            ...fak2lak.map((pk) => transaction_1.deleteKey(pk)),\n            ...fak2lak.map((pk) => transaction_1.addKey(pk, transaction_1.functionCallAccessKey(accountId, exports.MULTISIG_CHANGE_METHODS, null))),\n            transaction_1.addKey(confirmOnlyKey, transaction_1.functionCallAccessKey(accountId, exports.MULTISIG_CONFIRM_METHODS, null)),\n            transaction_1.deployContract(contractBytes),\n        ];\n        const newFunctionCallActionBatch = actions.concat(transaction_1.functionCall('new', newArgs, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT));\n        console.log('deploying multisig contract for', accountId);\n        const { stateStatus: multisigStateStatus } = await this.checkMultisigCodeAndStateStatus(contractBytes);\n        switch (multisigStateStatus) {\n            case MultisigStateStatus.STATE_NOT_INITIALIZED:\n                return await super.signAndSendTransactionWithAccount(accountId, newFunctionCallActionBatch);\n            case MultisigStateStatus.VALID_STATE:\n                return await super.signAndSendTransactionWithAccount(accountId, actions);\n            case MultisigStateStatus.INVALID_STATE:\n                throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState');\n            default:\n                throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n        }\n    }\n    async disableWithFAK({ contractBytes, cleanupContractBytes }) {\n        let cleanupActions = [];\n        if (cleanupContractBytes) {\n            await this.deleteAllRequests().catch(e => e);\n            cleanupActions = await this.get2faDisableCleanupActions(cleanupContractBytes);\n        }\n        const keyConversionActions = await this.get2faDisableKeyConversionActions();\n        const actions = [\n            ...cleanupActions,\n            ...keyConversionActions,\n            transaction_1.deployContract(contractBytes)\n        ];\n        const accessKeyInfo = await this.findAccessKey(this.accountId, actions);\n        if (accessKeyInfo && accessKeyInfo.accessKey && accessKeyInfo.accessKey.permission !== 'FullAccess') {\n            throw new providers_1.TypedError(`No full access key found in keystore. Unable to bypass multisig`, 'NoFAKFound');\n        }\n        return this.signAndSendTransactionWithAccount(this.accountId, actions);\n    }\n    async get2faDisableCleanupActions(cleanupContractBytes) {\n        const currentAccountState = await this.viewState('').catch(error => {\n            const cause = error.cause && error.cause.name;\n            if (cause == 'NO_CONTRACT_CODE') {\n                return [];\n            }\n            throw cause == 'TOO_LARGE_CONTRACT_STATE'\n                ? new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState')\n                : error;\n        });\n        const currentAccountStateKeys = currentAccountState.map(({ key }) => key.toString('base64'));\n        return currentAccountState.length ? [\n            transaction_1.deployContract(cleanupContractBytes),\n            transaction_1.functionCall('clean', { keys: currentAccountStateKeys }, exports.MULTISIG_GAS, new bn_js_1.default('0'))\n        ] : [];\n    }\n    async get2faDisableKeyConversionActions() {\n        const { accountId } = this;\n        const accessKeys = await this.getAccessKeys();\n        const lak2fak = accessKeys\n            .filter(({ access_key }) => access_key.permission !== 'FullAccess')\n            .filter(({ access_key }) => {\n            const perm = access_key.permission.FunctionCall;\n            return perm.receiver_id === accountId &&\n                perm.method_names.length === 4 &&\n                perm.method_names.includes('add_request_and_confirm');\n        });\n        const confirmOnlyKey = key_pair_1.PublicKey.from((await this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);\n        return [\n            transaction_1.deleteKey(confirmOnlyKey),\n            ...lak2fak.map(({ public_key }) => transaction_1.deleteKey(key_pair_1.PublicKey.from(public_key))),\n            ...lak2fak.map(({ public_key }) => transaction_1.addKey(key_pair_1.PublicKey.from(public_key), transaction_1.fullAccessKey()))\n        ];\n    }\n    /**\n     * This method converts LAKs back to FAKs, clears state and deploys an 'empty' contract (contractBytes param)\n     * @param [contractBytes]{@link https://github.com/near/near-wallet/blob/master/packages/frontend/src/wasm/main.wasm?raw=true}\n     * @param [cleanupContractBytes]{@link https://github.com/near/core-contracts/blob/master/state-cleanup/res/state_cleanup.wasm?raw=true}\n     */\n    async disable(contractBytes, cleanupContractBytes) {\n        const { stateStatus } = await this.checkMultisigCodeAndStateStatus();\n        if (stateStatus !== MultisigStateStatus.VALID_STATE && stateStatus !== MultisigStateStatus.STATE_NOT_INITIALIZED) {\n            throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n        }\n        let deleteAllRequestsError;\n        await this.deleteAllRequests().catch(e => deleteAllRequestsError = e);\n        const cleanupActions = await this.get2faDisableCleanupActions(cleanupContractBytes).catch(e => {\n            if (e.type === 'ContractHasExistingState') {\n                throw deleteAllRequestsError || e;\n            }\n            throw e;\n        });\n        const actions = [\n            ...cleanupActions,\n            ...(await this.get2faDisableKeyConversionActions()),\n            transaction_1.deployContract(contractBytes),\n        ];\n        console.log('disabling 2fa for', this.accountId);\n        return await this.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions\n        });\n    }\n    async sendCodeDefault() {\n        const { accountId } = this;\n        const { requestId } = this.getRequest();\n        const method = await this.get2faMethod();\n        await this.postSignedJson('/2fa/send', {\n            accountId,\n            method,\n            requestId,\n        });\n        return requestId;\n    }\n    async getCodeDefault(method) {\n        throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is \"email\" or \"phone\".');\n    }\n    async promptAndVerify() {\n        const method = await this.get2faMethod();\n        const securityCode = await this.getCode(method);\n        try {\n            const result = await this.verifyCode(securityCode);\n            // TODO: Parse error from result for real (like in normal account.signAndSendTransaction)\n            return result;\n        }\n        catch (e) {\n            console.warn('Error validating security code:', e);\n            if (e.toString().includes('invalid 2fa code provided') || e.toString().includes('2fa code not valid')) {\n                return await this.promptAndVerify();\n            }\n            throw e;\n        }\n    }\n    async verifyCodeDefault(securityCode) {\n        const { accountId } = this;\n        const request = this.getRequest();\n        if (!request) {\n            throw new Error('no request pending');\n        }\n        const { requestId } = request;\n        return await this.postSignedJson('/2fa/verify', {\n            accountId,\n            securityCode,\n            requestId\n        });\n    }\n    async getRecoveryMethods() {\n        const { accountId } = this;\n        return {\n            accountId,\n            data: await this.postSignedJson('/account/recoveryMethods', { accountId })\n        };\n    }\n    async get2faMethod() {\n        let { data } = await this.getRecoveryMethods();\n        if (data && data.length) {\n            data = data.find((m) => m.kind.indexOf('2fa-') === 0);\n        }\n        if (!data)\n            return null;\n        const { kind, detail } = data;\n        return { kind, detail };\n    }\n    async signatureFor() {\n        const { accountId } = this;\n        const block = await this.connection.provider.block({ finality: 'final' });\n        const blockNumber = block.header.height.toString();\n        const signed = await this.connection.signer.signMessage(Buffer.from(blockNumber), accountId, this.connection.networkId);\n        const blockNumberSignature = Buffer.from(signed.signature).toString('base64');\n        return { blockNumber, blockNumberSignature };\n    }\n    async postSignedJson(path, body) {\n        return await web_1.fetchJson(this.helperUrl + path, JSON.stringify({\n            ...body,\n            ...(await this.signatureFor())\n        }));\n    }\n}\nexports.Account2FA = Account2FA;\n// helpers\nconst toPK = (pk) => key_pair_1.PublicKey.from(pk);\nconst convertPKForContract = (pk) => pk.toString().replace('ed25519:', '');\nconst convertActions = (actions, accountId, receiverId) => actions.map((a) => {\n    const type = a.enum;\n    const { gas, publicKey, methodName, args, deposit, accessKey, code } = a[type];\n    const action = {\n        type: type[0].toUpperCase() + type.substr(1),\n        gas: (gas && gas.toString()) || undefined,\n        public_key: (publicKey && convertPKForContract(publicKey)) || undefined,\n        method_name: methodName,\n        args: (args && Buffer.from(args).toString('base64')) || undefined,\n        code: (code && Buffer.from(code).toString('base64')) || undefined,\n        amount: (deposit && deposit.toString()) || undefined,\n        deposit: (deposit && deposit.toString()) || '0',\n        permission: undefined,\n    };\n    if (accessKey) {\n        if (receiverId === accountId && accessKey.permission.enum !== 'fullAccess') {\n            action.permission = {\n                receiver_id: accountId,\n                allowance: exports.MULTISIG_ALLOWANCE.toString(),\n                method_names: exports.MULTISIG_CHANGE_METHODS,\n            };\n        }\n        if (accessKey.permission.enum === 'functionCall') {\n            const { receiverId: receiver_id, methodNames: method_names, allowance } = accessKey.permission.functionCall;\n            action.permission = {\n                receiver_id,\n                allowance: (allowance && allowance.toString()) || undefined,\n                method_names\n            };\n        }\n    }\n    return action;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}